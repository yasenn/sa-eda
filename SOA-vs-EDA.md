# SOA vs. EDA: Is Not Life Simply a Series of Events?
[SOA vs. EDA: Is Not Life Simply a Series of Events? | Confluent](https://www.confluent.io/blog/soa-vs-eda-is-not-life-simply-a-series-of-events/)

> _Yoda would have said, “Physical and temporal decoupling it is!”_

Applications built using an event-driven architecture tend to have a simple relationship between the components, which is unidirectional in nature. You have event sources and event handlers, also referred to as sources and sinks. Both of these components can be producers and consumers.

Typically a producer will send events to multiple consumers. In order to facilitate independent and asynchronous computing, we need a middleware component to manage the delivery of events. This is commonly known as an event broker, an intermediary that manages the delivery of events from producers to consumers. One can standardize these to be event adapters (producers), an event hub (broker) and event processors (consumers). Note that consumers can become producers also. This is illustrated in the following diagram:

![Event Source ➝ Event Adapters ➝ Event Hub ➝ Event Processors ➝ Outcome Delivery](https://cdn.confluent.io/wp-content/uploads/SOA_vs_EDA.jpg)

Compared to SOA, the essence of an EDA is that the services involved communicate through the capture, propagation, processing and persistence of events. This resulting pattern of communicating through a dataflow is quite different from the SOA approach of requests and responses. Here are some reasons why the EDA patterns can alleviate some of the challenges traditional SOA patterns bring:


|                                                                          | SOA                                                                                                                                                                                                                                                                                                                                                                         | EDA                                                                                                                                                                                                                                                                                                                                                                              |
|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Pull vs. Reactive                                                        | Client makes a request of a service and expects a response. It’s great for persisted, static data, but gets a little hard when data keeps changing. You have to poll to detect changes.                                                                                                                                                                                     | Subscription model pushes events to consumers.                                                                                                                                                                                                                                                                                                                                   |
| Coupling                                                                 | Client has to know details of the API and its location at runtime.                                                                                                                                                                                                                                                                                                          | Producers have no knowledge of consumer which will ultimately receive the event. There is still some minimal coupling in terms names of queues/topics and event formats.                                                                                                                                                                                                         |
| Service Availability                                                     | A service must be available at the time a request is made by a client even if you are doing an asynchronous response handling.                                                                                                                                                                                                                                              | Events do not require a reply and are inherently asynchronous. Events can be persisted for future consumption. With a highly fault-tolerant broker, the event producer does not need to know whether the consumers are available. Thus, we achieve higher resilience to network and compute failure, and this allows event producers to avoid blocking.                          |
| Process Modification and Extension                                       | Processing logic is a request-response API that is hardwired into a service endpoint (with or without service discovery). If the logic needs to change or be extended, or if new logic needs to be introduced, the definition (not contract) of the service must be updated. This introduces change management and regression risk.                                         | Additional event producers and consumers can be added to a system without any explicit process definition.                                                                                                                                                                                                                                                                       |
| Consistency Between Process Interaction and Internal State Management    | State changes are managed based on requests. For example, a request to “withdraw money” mutates the state of an account. The distinct processes of a request, a change in state and its persistence in case of failure must be tied together transactionally. This often leads users to deploy expensive distributed transaction protocols like eXtended architecture (XA). | EDA provides better support for consistency between process interaction and persisted internal state transitions. This is done through the event sourcing pattern, where the communication protocol (the event) is also the persistence mechanism (the event log). The current state of a system can be built or rebuilt from the log of events.                                 |
| Retaining the Exact State Transitions That Customers or Services Perform | In SOAs, data is typically “mutated in place” in a database. This is a lossy process where each state change loses the information about the state changes that happened previously.                                                                                                                                                                                        | EDAs are event sourced, meaning every state change is captured, providing a truthful journal of the exact state changes that every customer or every service made over time. This journal lets operators rewind time to view or replay previous events exactly as they happened. It is also important for analytics that review customer (or system) behavior to derive insight. |
| Streaming Analytics                                                      | SOA is incapable of deriving analytics of data in flight. This requires the ability to detect a pattern from multiple state changes both temporally and spatially.                                                                                                                                                                                                          | EDA is fully capable of detecting patterns across multiple event sources over many different types of time windows. Also, deriving analytics of data in flight is a means of continuous intelligence.                                                                                                                                                                            |
| The Timing of Consistency and of Intelligence                            | Synchronous communication makes it a bit easier to create consistent state across services from a client’s perspective. Intelligence from the consistent state are derived eventually—that is, eventual intelligence and continuous consistency                                                                                                                             | Events, being asynchronous, mean that different services become consistent with one another only in eventuality: There is no control over the timeliness of the process of event propagation.                                                                                                                                                                                    |

Ultimately, the choice between SOA or EDA depends on what you are trying to achieve and the problems you are trying to solve. What is your priority? Is it eventual intelligence–to maintain state first and then later derive insight, or is it continuous intelligence–responding to change and deriving insight as soon as it happens? These are very different things. The first systems are simple information custodians. In the second, the business functions as a deeply connected [central nervous system](https://blogs.gartner.com/yefim_natis/2017/09/12/event-thinking-a-challenge-and-an-imperative/). In fact, the most fascinating concept I have come across in recent times is one that is impossible to achieve without an EDA. It is the concept of a digital twin, but I will save that for another post.

All that said, EDA does not supplant SOA, meaning that SOA, or traditional state persistence and data management, does not go away. EDA is not a cure for all computing woes. There will always be the need for synchronous request-response, API-based computing where a service consumer needs to make a request and wait for the response to come back. There will also be cases where the complexity and cost of managing events deliver no justifiable benefit. In order to deliver strong lasting solutions, one must combine event-driven patterns with more traditional patterns to achieve the optimal integration complexity and appropriate for developer productivity.
